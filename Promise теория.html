<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>

<script>
    'use strict';



    // Функция, переданная в конструкцию new Promise, называется исполнитель (executor).
    // Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код,
    // который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».
    //
    // Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.
    // Наш код – только внутри исполнителя.
    //
    //     Когда он получает результат, сейчас или позже – не важно,
    //     он должен вызвать один из этих колбэков:
    //
    //     resolve(value) — если работа завершилась успешно, с результатом value.
    // reject(error) — если произошла ошибка, error – объект ошибки.
    //     Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.
    //
    //     У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
    //
    //     --state («состояние») — вначале "pending" («ожидание»),
    //     потом меняется на "fulfilled" («выполнено успешно») при вызове resolve
    //     или на "rejected" («выполнено с ошибкой») при вызове reject.
    //     --result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value)
    // или на error при вызове reject(error).

    // Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):

    let promise = new Promise(function(resolve, reject) {
        // эта функция выполнится автоматически, при вызове new Promise

        // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
        setTimeout(() => resolve("done"), 1000);
    });
    // Мы можем наблюдать две вещи, запустив код выше:
    //
    //     Функция-исполнитель запускается сразу же при вызове new Promise.
    // Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript,
    // поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.
    //     Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат:

    // Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
    //
    //     А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

        let promise = new Promise(function(resolve, reject) {
            // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
            setTimeout(() => reject(new Error("Whoops!")), 1000);
        });

    // Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
    //
    //     Все последующие вызовы resolve и reject будут проигнорированы:

        let promise = new Promise(function(resolve, reject) {
            resolve("done");

            reject(new Error("…")); // игнорируется
            setTimeout(() => resolve("…")); // игнорируется
        });
    // Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа.
    //     Для обработки результата следует использовать методы .then/.catch/.finally








    promise.then(
        function(result) { /* обработает успешное выполнение */ },
        function(error) { /* обработает ошибку */ }
    );

    // Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
    //
    //     Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
    //
    //     Например, вот реакция на успешно выполненный промис:

        let promise = new Promise(function(resolve, reject) {
            setTimeout(() => resolve("done!"), 1000);
        });

    // resolve запустит первую функцию, переданную в .then
    promise.then(
        result => alert(result), // выведет "done!" через одну секунду
        error => alert(error) // не будет запущена
    );

    // Выполнилась первая функция.
    //
    //     А в случае ошибки в промисе – выполнится вторая:

        let promise = new Promise(function(resolve, reject) {
            setTimeout(() => reject(new Error("Whoops!")), 1000);
        });

    // reject запустит вторую функцию, переданную в .then
    promise.then(
        result => alert(result), // не будет запущена
        error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
    );

    let promise = new Promise(function(resolve, reject) {
        setTimeout(() => resolve("done!"), 1000);
    });

    // resolve запустит первую функцию, переданную в .then
    promise.then(
        result => alert(result), // выведет "done!" через одну секунду
        error => alert(error) // не будет запущена
    );



    // catch
    // Если мы хотели бы только обработать ошибку, то можно использовать null
    // в качестве первого аргумента: .then(null, errorHandlingFunction).
    // Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:

        let promise = new Promise((resolve, reject) => {
            setTimeout(() => reject(new Error("Ошибка!")), 1000);
        });

    // .catch(f) это тоже самое, что promise.then(null, f)
    // promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
    // Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).


    // finally
    // По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.
    //
    // Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис
    // завершится: успешно или с ошибкой.



    // Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис.
    // И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
    //
    //     Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
    //
    //     Например, здесь результат проходит через finally к then:

        new Promise((resolve, reject) => {
            setTimeout(() => resolve("result"), 2000)
        })
            .finally(() => alert("Промис завершён"))
            .then(result => alert(result)); // <-- .then обработает результат
    // А здесь ошибка из промиса проходит через finally к catch:

    new Promise((resolve, reject) => {
        throw new Error("error");
    })
        .finally(() => alert("Промис завершён"))
        .catch(err => alert(err));  // <-- .catch обработает объект ошибки
    // Это очень удобно, потому что finally не предназначен для обработки результата промиса.
    // Так что он просто пропускает его через себя дальше.



    // Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его. Однако,
    // если промис уже завершён, то обработчики выполнятся сразу:

    // при создании промиса он сразу переводится в состояние "успешно завершён"
    let promise = new Promise(resolve => resolve("готово!"));

    promise.then(alert); // готово! (выведется сразу)





    // вариант с колбэками:

        function loadScript(src, callback) {
            let script = document.createElement('script');
            script.src = src;

            script.onload = () => callback(null, script);
            script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

            document.head.append(script);
        }

    // Теперь перепишем её, используя Promise.
    //
    //     Новой функции loadScript более не нужен аргумент callback.
    //     Вместо этого она будет создавать и возвращать объект Promise, который перейдет
    //     в состояние «успешно завершён», когда загрузка закончится. Внешний код может
    //     добавлять обработчики («подписчиков»), используя .then:

    function loadScript(src) {
        return new Promise(function(resolve, reject) {
            let script = document.createElement('script');
            script.src = src;

            script.onload = () => resolve(script);
            script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

            document.head.append(script);
        });
    }


    // Промисы	Колбэки
    // Промисы позволяют делать вещи в естественном порядке.
    //     Сперва мы запускаем loadScript(script), и затем (.then) мы пишем, что делать с результатом.
    //     У нас должна быть функцияcallback на момент вызова loadScript(script, callback).
    //     Другими словами, нам нужно знать что делать с результатом до того, как вызовется loadScript.
    //     Мы можем вызывать .then у Promise столько раз, сколько захотим.
    //     Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок».
    // Больше об этом в следующей главе: Цепочка промисов.	Колбэк может быть только один.

</script>
</body>
</html>